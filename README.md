# dynamic_array

**Динамічний масив** — це структура даних, яка зберігає елементи в суцільному блоці памʼяті та автоматично збільшує свою місткість (*capacity*), коли місце закінчується.

**Збільшення capacity** відбувається не по 1 елементу, а стрибками — щоб операція `append` у середньому була швидкою.

**growth_factor** — коефіцієнт, на який множиться поточна capacity під час розширення.  
Наприклад, `1.5` означає +50% до розміру.

**Resize** відбувається тоді, коли кількість елементів дорівнює поточній capacity — створюється новий масив більшого розміру і всі елементи копіюються.

---

## Пояснення роботи коду

- `__init__`  
  Ініціалізує масив, початкову capacity, лічильник елементів та параметри росту.

- `append`  
  Додає елемент у кінець масиву. Якщо місця нема — викликає `_resize`.

- `_resize`  
  Створює новий масив більшого розміру, копіює всі елементи та збільшує `resize_count`.

**Final capacity** — фактичний розмір внутрішнього масиву після всіх вставок.  
**resize_count** — скільки разів відбувалось перевиділення памʼяті.

---

## Перевірка

Вставлено **1 000 000** елементів для різних `growth_factor`.

### Результати
#### Growth Factor: 1.2
| number of elements | final capacity | resize count | wasted memory |
|--------------------|----------------|--------------|---------------|
| 1                  | 1              | 0            | 0             |
| 100                | 105            | 23           | 5             |
| 1000               | 1111           | 36           | 111           |
| 10000              | 11866          | 49           | 1866          |
| 100000             | 105780         | 61           | 5780          |

---
#### Growth Factor: 1.5
| number of elements | final capacity | resize count | wasted memory |
|--------------------|----------------|--------------|---------------|
| 1                  | 1              | 0            | 0             |
| 100                | 141            | 12           | 41            |
| 1000               | 1066           | 17           | 66            |
| 10000              | 12138          | 23           | 2138          |
| 100000             | 138255         | 29           | 38255         |

---
#### Growth Factor: 2.0
| number of elements | final capacity | resize count | wasted memory |
|--------------------|----------------|--------------|---------------|
| 1                  | 1              | 0            | 0             |
| 100                | 128            | 7            | 28            |
| 1000               | 1024           | 10           | 24            |
| 10000              | 16384          | 14           | 6384          |
| 100000             | 131072         | 17           | 31072         |

---
| growth_factor | initial capacity | elements | resize count | wasted memory |
|---------------|------------------|----------|--------------|---------------|
| 1.2           | 8                | 105780   | 54           | 5780          |
| 1.2           | 32               | 109256   | 45           | 9256          |
| 1.2           | 128              | 106525   | 37           | 6525          |
| 1.5           | 8                | 132387   | 24           | 32387         |
| 1.5           | 32               | 106204   | 20           | 6204          |
| 1.5           | 128              | 126090   | 17           | 26090         |
| 2.0           | 8                | 131072   | 14           | 31072         |
| 2.0           | 32               | 131072   | 12           | 31072         |
| 2.0           | 128              | 131072   | 10           | 31072         |


## Графік

Залежність зайвої памʼяті від `growth_factor`:

![Графік залежності](grafic.png)

## Висновок

- `growth_factor = 1.2` — мінімум зайвої памʼяті, але багато resize — повільніше.
- `growth_factor = 2.0` — мінімум resize, але багато зайвої памʼяті.
- `growth_factor = 1.5` — найкращий баланс між кількістю перевиділень і витратами памʼяті.